---
title: '深浅拷贝'
---

#### 数组和对象的浅拷贝

```javascript
let obj = {
  value:1
}
let a = obj

a.value = 2

console.log(obj)
//obj{value:2}
```

此时的obj里的value已经变成了2原因是，对象的赋值不像基本数据类型 number string 那种，直接赋值。
对象类型的数组是引用赋值，obj指向的 value:1这个对象的地址引用，a = obj，将a也指向了这个地址的引用
a和obj都指向同一个地址的引用，所以当你改变a的值，也就是改变了value的值，所以obj的值也会改变

#### 数组的浅拷贝

如果是数组，我们可以利用数组的一些方法比如：slice、concat 返回一个新数组的特性来实现拷贝

```javascript
let arr = [{old: 'old'}, ['old']];

let new_arr = arr.concat();

arr[0].old = 'new';
arr[1][0] = 'new';

console.log(arr) // [{old: 'new'}, ['new']]
console.log(new_arr) // [{old: 'new'}, ['new']]
```

可以使用concat和slice对数组进行拷贝

#### 简单粗暴的深拷贝

使用JSON.stringify和JSON.parse进行拷贝

```javascript

let arr = ['xxx', 1, true, ['new', '222'], {old: 1}]

let new_arr = JSON.parse( JSON.stringify(arr) );

console.log(new_arr);
```

这样新的new_arr就是一个深拷贝对象

* JSON.stringify存在得问题，不能进行函数得深拷贝

```javascript
var arr = [function(){
    console.log(a)
}, {
    b: function(){
        console.log(b)
    }
}]

var new_arr = JSON.parse(JSON.stringify(arr));

console.log(new_arr);
//new_arr[null,{}]
```

第一项变成null，第二项变成了空对象
