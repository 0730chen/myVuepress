---
title:复习
---
1.如何理解Html语义化标签
HTML 语义化就是使用正确的标签（总结）段落就写 p 标签，标题就写 h1 标签，文章就写article标签，视频就写video标签，等等

2.meta viewport 是做什么用的，怎么写？
```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
```
meta是元的意思

name属性为viewport，视图，窗口,它提供有关视口初始大小的提示，仅供移动设备使用。

content属性 width：设备宽度，height:设备高度，initial-scale：定义设备宽度（纵向模式下的设备宽度或横向模式下的设备高度）与视口大小之间的缩放比率。
maximum-scale:定义缩放的最小值
minimum-scale：定义缩放最大值
user-scalable：定义是否允许用户缩放

3.常用的H5标签
```html
<nav/>
<footer/>
<main/>
<aside/>
```

4.什么是H5？

h5是移动端页面，运行在微信浏览器就是微信H5

5.两种盒模型

   content-box就是元素的width和height决定了元素的宽高，这意味着元素的border和padding等不能算在元素的width和height中 ，padding和border的改变不能改变width和height的值。

   border-box:border-box就是用元素内容和padding和border一起决定width和height，啥意思，就是width和元素的内容以及padding和border相互制约。下面用几句话简洁解释一下。
•width和height改变，paddign和border不改变时，元素内容的宽高会发生相应的改变，改变的值就是width和height改变的值。
•paddign和border改变，width和height不改变时，元素内容的宽高会发生相应的改变，改变的值就是width和height改变的值。

6.垂直居中

table自带功能1.5K

100% 高度的 afrer before 加上 inline block1.0K
这个方法还有一个优化版本484

div 装成 table

margin-top -50%

translate -50%

absolute margin auto

flex

7.BFC块级上下文

下列方式会创建块格式化上下文：

* 根元素
* 浮动元素（元素的 float 不是 none）
* 绝对定位元素（元素的 position 为 absolute 或 fixed）
* 行内块元素
* overflow 值不为 visible 的块元素
* 弹性元素（display为 flex 或 inline-flex元素的直接子元素）

用途

创建新的BFC避免两个相邻标签之间的外边距合并问题

一个新的 display 属性的值，它可以创建无副作用的BFC。在父级块中使用 display: flow-root 可以创建新的BFC。

8. CSS 选择器优先级
* 越具体优先级越高
* 同样优先级写在后面的覆盖写在前面的
* !important 优先级最高，但是要少用

9.清除浮动
```css
.clearfix:after{
     content: '';
     display: block; /*或者 table*/
     clear: both;
 }
 .clearfix{
     zoom: 1; /* IE 兼容*/
 }
```
10.防抖和节流
```javascript
// 节流（一段时间执行一次之后，就不执行第二次），有节制的执行，一段时间只执行一次
 function throttle(fn, delay){
     let canUse = true
     return function(){
         if(canUse){
             fn.apply(this, arguments)
             canUse = false
             setTimeout(()=>canUse = true, delay)
         }
     }
 }

 const throttled = throttle(()=>console.log('hi'))
 throttled()
 throttled()
```
```javascript
// 防抖（一段时间会等，然后带着一起做了） 事件触发后一段时间执行函数
 function debounce(fn, delay){
     let timerId = null
     return function(){
         const context = this
         if(timerId){window.clearTimeout(timerId)}
         timerId = setTimeout(()=>{
             fn.apply(context, arguments)
             timerId = null
         },delay)
     }
 }
 const debounced = debounce(()=>console.log('hi'))
 debounced()
 debounced()
```
11.手写ajax
```javascript
 var request = new XMLHttpRequest()
 request.open('GET', '/a/b/c?name=ff', true);
 request.onreadystatechange = function () {
   if(request.readyState === 4 && request.status === 200) {
     console.log(request.responseText);
   }};
 request.send();
```
12.jsonp

 * JSONP是通过 script 标签加载数据的方式去获取数据当做 JS 代码来执行

 * 提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。换句话说，JSONP 需要对应接口的后端的配合才能实现。
 ```javascript
window.show = data=>{
     console.log(data)
     }
 //show函数接受一个参数，然后打印这个参数
     let script = document.createElement('script')
         script.src = 'Url'，接口地址
     script.onload = ()=>{
         //传递完之后移除这个标签
          script.remove()        
         }
     document.body.appenndChild(script)
     //服务端
     res.statusCode = 200
     res.setHeader('Content-Type', "text/javascript;charset=utf-8")
     res.write(show('data'))
     res.end()
```
 13.实现一个trim函数
 ```javascript
String.prototype.trim = function(){
    return this.replace(/^\s+|\s+$/g, '')
}
//或者 
function trim(string){
    return string.replace(/^\s+|\s+$/g, '')
}
```