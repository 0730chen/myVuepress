
#### 面试
1.如何理解Html语义化标签
HTML 语义化就是使用正确的标签（总结）段落就写 p 标签，标题就写 h1 标签，文章就写article标签，视频就写video标签，等等

2.meta viewport 是做什么用的，怎么写？
```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
```
meta是元的意思

name属性为viewport，视图，窗口,它提供有关视口初始大小的提示，仅供移动设备使用。

content属性 width：设备宽度，height:设备高度，initial-scale：定义设备宽度（纵向模式下的设备宽度或横向模式下的设备高度）与视口大小之间的缩放比率。
maximum-scale:定义缩放的最小值
minimum-scale：定义缩放最大值
user-scalable：定义是否允许用户缩放

3.常用的H5标签
```html
<nav/>
<footer/>
<main/>
<aside/>
```

4.什么是H5？

h5是移动端页面，运行在微信浏览器就是微信H5

5.两种盒模型

   content-box就是元素的width和height决定了元素的宽高，这意味着元素的border和padding等不能算在元素的width和height中 ，padding和border的改变不能改变width和height的值。

   border-box:border-box就是用元素内容和padding和border一起决定width和height，啥意思，就是width和元素的内容以及padding和border相互制约。下面用几句话简洁解释一下。
•width和height改变，paddign和border不改变时，元素内容的宽高会发生相应的改变，改变的值就是width和height改变的值。
•paddign和border改变，width和height不改变时，元素内容的宽高会发生相应的改变，改变的值就是width和height改变的值。

6.垂直居中

table自带功能1.5K

100% 高度的 afrer before 加上 inline block1.0K
这个方法还有一个优化版本484

div 装成 table

margin-top -50%

translate -50%

absolute margin auto

flex

7.BFC块级上下文

下列方式会创建块格式化上下文：

* 根元素
* 浮动元素（元素的 float 不是 none）
* 绝对定位元素（元素的 position 为 absolute 或 fixed）
* 行内块元素
* overflow 值不为 visible 的块元素
* 弹性元素（display为 flex 或 inline-flex元素的直接子元素）

用途

创建新的BFC避免两个相邻标签之间的外边距合并问题

一个新的 display 属性的值，它可以创建无副作用的BFC。在父级块中使用 display: flow-root 可以创建新的BFC。

8. CSS 选择器优先级
* 越具体优先级越高
* 同样优先级写在后面的覆盖写在前面的
* !important 优先级最高，但是要少用

9.清除浮动
```css
.clearfix:after{
     content: '';
     display: block; /*或者 table*/
     clear: both;
 }
 .clearfix{
     zoom: 1; /* IE 兼容*/
 }
```
10.防抖和节流
```javascript
// 节流（一段时间执行一次之后，就不执行第二次），有节制的执行，一段时间只执行一次
 function throttle(fn, delay){
     let canUse = true
     return function(){
         if(canUse){
             fn.apply(this, arguments)
             canUse = false
             setTimeout(()=>canUse = true, delay)
         }
     }
 }

 const throttled = throttle(()=>console.log('hi'))
 throttled()
 throttled()
```
```javascript
// 防抖（一段时间会等，然后带着一起做了） 事件触发后一段时间执行函数
 function debounce(fn, delay){
     let timerId = null
     return function(){
         const context = this
         if(timerId){window.clearTimeout(timerId)}
         timerId = setTimeout(()=>{
             fn.apply(context, arguments)
             timerId = null
         },delay)
     }
 }
 const debounced = debounce(()=>console.log('hi'))
 debounced()
 debounced()
```
11.手写ajax
```javascript
 var request = new XMLHttpRequest()
 request.open('GET', '/a/b/c?name=ff', true);
 request.onreadystatechange = function () {
   if(request.readyState === 4 && request.status === 200) {
     console.log(request.responseText);
   }};
 request.send();
```
12.jsonp

 * JSONP是通过 script 标签加载数据的方式去获取数据当做 JS 代码来执行

 * 提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。换句话说，JSONP 需要对应接口的后端的配合才能实现。
 ```javascript
window.show = data=>{
     console.log(data)
     }
 //show函数接受一个参数，然后打印这个参数
     let script = document.createElement('script')
         script.src = 'Url'，接口地址
     script.onload = ()=>{
         //传递完之后移除这个标签
          script.remove()        
         }
     document.body.appenndChild(script)
     //服务端
     res.statusCode = 200
     res.setHeader('Content-Type', "text/javascript;charset=utf-8")
     res.write(show('data'))
     res.end()
```
 13.实现一个trim函数
 ```javascript
String.prototype.trim = function(){
    return this.replace(/^\s+|\s+$/g, '')
}
//或者 
function trim(string){
    return string.replace(/^\s+|\s+$/g, '')
}
```
14.在项目中遇到的难点
橘子记账
功能描述：点击记录按钮，将当前的金额，消费类型，备注，标签，存放在一个对象中，每点击记录一次就会在数组中添加一个对象
问题描述: 第二次提交的内容会修改第一次提交的内容，第三次提交的内容会修改前两次提交的内容
原因:每次向数组中push的是一个对象，push的是对象的引用，假如对象的地址是404则每次push的对象都是同一个地址的对象，就会修改之前的内容
解决方法:进行深拷贝，对提交的对象进行深拷贝，将深拷贝的值储存到数组中
let data = JSON.parse(JSON.stringify(data))
功能描述:底部导航布局问题，需要在底部固定
问题描述:使用fixed定位布局在移动端唤醒软键盘时会失效，父元素transform不为none的时候，fixed会失效
解决方法:不适应fixed布局，使用flex布局使导航栏固定在底部

15.get和post的区别

GET在浏览器回退时是无害的，而POST会再次提交请求。

GET产生的URL地址可以被加入收藏栏，而POST不可以。

GET请求会被浏览器主动cache，而POST不会，除非手动设置。

GET请求只能进行url编码，而POST支持多种编码方式。

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

GET请求在URL中传送的参数是有长度限制的，而POST么有。

对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

GET参数通过URL传递，POST放在Request body中。

正解

就一个区别：语义——GET 用于获取资源，POST 用于提交资源。