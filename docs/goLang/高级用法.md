---
title: 高级用法
date: 2020-09-14
tags:
- go
- 服务端
categories:
- golang
---

#### 数组切片 Slice

* 切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递
* 切片的长度可以改变，因此，切片是一个可变的数组。
* 切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。
* cap可以求出slice最大扩张容量，不能超出数组限制。0 <= len(slice) <= len(array)，其中array是slice引用的数组
* 切片的定义：var 变量名 []类型，比如 var str []string  var arr []int
* 如果 slice == nil，那么 len、cap 结果都等于 0。
* 切片（slice）是建立在数组之上的更方便，更灵活，更强大的数据结构。切片并不存储任何元素而只是对现有数组的引用。

```go

package main

import "fmt"

//声明一个切片
func xxx() {
 //全局定义
 var s1 []int

 if s1 == nil {
  fmt.Println("是空")
 } else {
  fmt.Println("不是空")
 }

 //函数内部定义
 s2 := []int{}
 //make方式定义
 var s3 []int = make([]int, 0)

 //初始化赋值
 var s4 []int = make([]int, 0, 0)

 s5 := []int{1, 2, 3}

 //从数组中切片

 s6 := [5]int{1, 2, 3, 4, 5}

 var s7 []int

 //包含第一个但是不包含末尾的
 s7 = s6[1:4]

 a := [5]int{1, 2}
 fmt.Println("哈哈", a, s1, s2, s3, s4, s5, s7)
}

func main() {
 xxx()
}

```

#### 通过make创建切片

var 切片名 []type = make([], len, [cap])；参数说明：type是数据类型、len是大小、cap是切片容量（容量必须>=长度

```go
package main

import "fmt"

var arr = [...]int{0, 1, 2, 3, 4, 5, 6}
var slice0 []int = arr[2:4]
var slice1 []int = arr[0:6]
var slice2 []int = arr[2:5]

var slice3 []int = make([]int, 10)

//macke([]type,len,cap) type是类型，len是大小，cap是容量，容量必须大于等于长度
var slice4 []int = make([]int, 10, 10)

func sliceEm() {

 //切片定义

 fmt.Println("切片", arr, slice0, slice1, slice2)
}

func sliceOp() {
 data := [...]int{1, 2, 3, 4, 5, 8, 4, 1}

 sl := [...]int{1, 2, 3, 5, 4, 8: 100}

 s2 := make([]int, 6, 8) //使用mack指定len和cap值

 s3 := make([]int, 6) //不指定cap，默认等于len

 //s是一个切片
 s := data[0:4]
 s[0] += 100
 s[1] += 200

 s4 := []int{0, 1, 2, 3}

 p := &s[2] // *int, 获取底层数组元素指针。
 *p += 100

 //数组指针

 fmt.Println("我是一个切片", s, sl, s2, s3, s4)
}

```

使用 make 动态创建slice，避免了数组必须用常量做长度的麻烦。还可用指针直接访问底层数组，退化成普通数组操作。

至于 ```[][]T```，是指元素类型为 ```[]T```
