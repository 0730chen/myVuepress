(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{585:function(e,a,r){"use strict";r.r(a);var t=r(4),i=Object(t.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h4",{attrs:{id:"docker常用的部署工具"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker常用的部署工具"}},[e._v("#")]),e._v(" Docker常用的部署工具")]),e._v(" "),r("p",[e._v("Docker 是属于Linux容器的一种封装，提供简单易用的容器使用接口。是目前最流行的部署方案")]),e._v(" "),r("h4",{attrs:{id:"docker的用途"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker的用途"}},[e._v("#")]),e._v(" Docker的用途")]),e._v(" "),r("ul",[r("li",[e._v("提供一次性的环境")]),e._v(" "),r("li",[e._v("提供弹性的云服务")]),e._v(" "),r("li",[e._v("组建微服务架构")])]),e._v(" "),r("h4",{attrs:{id:"docker安装"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker安装"}},[e._v("#")]),e._v(" Docker安装")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("验证是否安装成功 docker version")])]),e._v(" "),r("li",[r("p",[e._v("给docker设置权限")])]),e._v(" "),r("li",[r("p",[e._v("sudo usermod -aG docker $USER")])]),e._v(" "),r("li",[r("p",[e._v("docker服务的启动命令")])]),e._v(" "),r("li",[r("p",[e._v("sudo service docker start")])]),e._v(" "),r("li",[r("p",[e._v("sudo systemctl start docker")])]),e._v(" "),r("li",[r("p",[e._v("指定启动的端口映射")])]),e._v(" "),r("li",[r("p",[e._v("-d代表让容器在后台运行")])]),e._v(" "),r("li",[r("p",[e._v("-p 支持的格式有 hostPort:containerPort、ip:hostPort:containerPort、 ip::containerPort。")])]),e._v(" "),r("li",[r("p",[e._v("调式命令sudo docker run -d -p 5000:5000 containername")])])]),e._v(" "),r("h4",{attrs:{id:"image"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#image"}},[e._v("#")]),e._v(" image")]),e._v(" "),r("p",[e._v("Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。")]),e._v(" "),r("p",[e._v("image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。")]),e._v(" "),r("ul",[r("li",[e._v("列出本机的所有 image 文件。-l列出最后一个部署的详细信息\ndocker image ls")])]),e._v(" "),r("h4",{attrs:{id:"删除-image-文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#删除-image-文件"}},[e._v("#")]),e._v(" 删除 image 文件")]),e._v(" "),r("p",[e._v("image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。")]),e._v(" "),r("ul",[r("li",[e._v("docker也有自己的dockerHub,可以寻找自己想要的下载使用")])]),e._v(" "),r("h4",{attrs:{id:"dockerfile文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile文件"}},[e._v("#")]),e._v(" DockerFile文件")]),e._v(" "),r("p",[e._v("学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。")]),e._v(" "),r("p",[e._v("这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。")]),e._v(" "),r("p",[e._v("下面通过一个实例，演示如何编写 Dockerfile 文件。")]),e._v(" "),r("h4",{attrs:{id:"创建一个dockerfile文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建一个dockerfile文件"}},[e._v("#")]),e._v(" 创建一个dockerFile文件")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("FROM node:8.4")])]),e._v(" "),r("li",[r("p",[e._v("COPY . /app")])]),e._v(" "),r("li",[r("p",[e._v("WORKDIR /app\n\x3c!-- * RUN npm install --registry="),r("a",{attrs:{href:"https://registry.npm.taobao.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://registry.npm.taobao.org"),r("OutboundLink")],1),e._v(" --\x3e")])]),e._v(" "),r("li",[r("p",[e._v("EXPOSE 3000")])]),e._v(" "),r("li",[r("p",[e._v("FROM node:8.4 该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。")])]),e._v(" "),r("li",[r("p",[e._v("COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。")])]),e._v(" "),r("li",[r("p",[e._v("WORKDIR /app：指定接下来的工作路径为/app。")])]),e._v(" "),r("li",[r("p",[e._v("RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。")])]),e._v(" "),r("li",[r("p",[e._v("EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。")])])]),e._v(" "),r("h4",{attrs:{id:"构建image"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建image"}},[e._v("#")]),e._v(" 构建image")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("构建项目名 -t指定image名  tag就是容器标签名\ndocker image build -tag name\ndocker build -t nginx-centos:6.7 .")])]),e._v(" "),r("li",[r("p",[e._v("t参数是image标签，, 代表是从当前目录寻找Dockerfile文件")])])]),e._v(" "),r("h4",{attrs:{id:"生成容器参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生成容器参数"}},[e._v("#")]),e._v(" 生成容器参数")]),e._v(" "),r("p",[e._v("docker run [option] <镜像名> [向启动容器中传入的命令]")]),e._v(" "),r("p",[e._v("docker container run -p 8000:3000 -it koa-demo /bin/bash")]),e._v(" "),r("p",[e._v("docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash")]),e._v(" "),r("p",[e._v("docker container run -d -p 3000:3000 -it music:1.0")]),e._v(" "),r("ul",[r("li",[e._v("-d,代表后台运行")]),e._v(" "),r("li",[e._v("-p参数：容器的 3000 端口映射到本机的 8000 端口。")]),e._v(" "),r("li",[e._v("-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。")]),e._v(" "),r("li",[e._v("koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。")]),e._v(" "),r("li",[e._v("/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell")])]),e._v(" "),r("h4",{attrs:{id:"停止容器运行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#停止容器运行"}},[e._v("#")]),e._v(" 停止容器运行")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("docker container ls")])]),e._v(" "),r("li",[r("p",[e._v("docker container stop option")])])]),e._v(" "),r("ul",[r("li",[e._v("查出容器的 ID\ndocker container ls --all")]),e._v(" "),r("li",[e._v("删除指定的容器文件\n")])]),e._v(" "),r("h4",{attrs:{id:"一些有用的命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一些有用的命令"}},[e._v("#")]),e._v(" 一些有用的命令")]),e._v(" "),r("div",{staticClass:"language-shell extra-class"},[r("pre",{pre:!0,attrs:{class:"language-shell"}},[r("code",[e._v("    docker container start  containerID 开始容器\n\n    docker container stop 终止容器运行\n\n    docker container logs or docker container logs -it 就要用这个命令查看输出。\n\n    docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用\n    -it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了\n\n    docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法\n\n    docker logs -f containerid 查询容器打印的log\n\n    docker "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("ps")]),e._v(" -a 列出所有的容器\n\n    docker image inspect --format"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),r("span",{pre:!0,attrs:{class:"token string"}},[e._v("'{{.RepoTags}} {{.Id}} {{.Parent}}'")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("$(")]),e._v("docker image "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" -q --filter "),r("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("since")]),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("xxxx） 查询相关容器\n\n    docker container "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" ID或者tag名 删除容器  \n\n")])])])])}),[],!1,null,null,null);a.default=i.exports}}]);